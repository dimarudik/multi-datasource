\pset pager off
\pset format wrapped
\set a 'select pid, usename, wait_event, query_id, query, state, query_start, client_addr, backend_xmin from pg_stat_activity order by query_start nulls first;'
\set top 'select A.total_connections, A.non_idle_connections, B.max_connections, round((100 * A.total_connections::numeric / B.max_connections::numeric), 2) connections_utilization_pctg from (select count(1) as total_connections, sum(case when state!=\'idle\' then 1 else 0 end) as non_idle_connections from pg_stat_activity) A, (select setting as max_connections from pg_settings where name=\'max_connections\') B;'
\set lsn 'select application_name, sync_state "state", pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn)) "sent lag", write_lag||$$ $$||pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), write_lsn)) "received on replica", flush_lag||$$ $$||pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), flush_lsn)) "flushed on replica",  replay_lag||$$ $$||pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn))  "applied in wal" from pg_stat_replication;'
\set slt 'select slot_name, plugin, slot_type, datoid, database, temporary, active, active_pid, xmin, catalog_xmin, restart_lsn, confirmed_flush_lsn, pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) lag from pg_replication_slots;'
\set qa 'select queryid, pg_get_userbyid(pss.userid) usename, plans, calls, calls/nullif(rows,0) as "RowsPerCall",  mean_plan_time "PlanTime", round(mean_exec_time::numeric, 4) "ExecTime", shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS "HitPercent", query from pg_stat_statements pss where pss.query like :\'st\';'
\set lk 'select pid, pg_blocking_pids(pid) blockers, locktype, mode, relation::regclass, page, tuple, transactionid, virtualtransaction, granted, waitstart, (select substring(query,1,90) from pg_stat_activity pa where pa.pid = pl.pid) query from pg_locks pl where pl.pid <> pg_backend_pid() and pl.locktype <> $$virtualxid$$ order by pid;'
\set lk12 'select pid, pg_blocking_pids(pid) blockers, locktype, mode, relation::regclass, page, tuple, transactionid, virtualtransaction, granted, (select substring(query,1,90) from pg_stat_activity pa where pa.pid = pl.pid) query from pg_locks pl where pl.pid <> pg_backend_pid() order by pid;'
-- select relid, schemaname, pgs.relname, pg_relation_size(schemaname||'.'||pgs.relname) size, n_tup_ins inserted, n_tup_upd updated, n_tup_del deleted, n_tup_hot_upd hot_upd, last_autovacuum, greatest(last_autoanalyze,last_analyze)||' (dead:'||n_dead_tup||')' as analyzed,  greatest(autovacuum_count, vacuum_count) as vacuum_cnt, age(pgc.relfrozenxid) from pg_stat_all_tables pgs, pg_class pgc where pgs.relid = pgc.oid and pgs.schemaname like '%xoct%' order by relname;
\set vc 'select pid, datid, datname, (select relname from pg_class where oid = relid) as relname, phase, heap_blks_total, heap_blks_scanned, heap_blks_vacuumed, index_vacuum_count, max_dead_tuples, num_dead_tuples from pg_stat_progress_vacuum ;'
-- select queryid, (select usename from pg_user pu where pu.usesysid = pgss.userid), plans, calls, calls/nullif(rows,0) as "RowsPerCall",  mean_plan_time "PlanTime", round(mean_exec_time::numeric, 4) "ExecTime", shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS "HitPercent", query from pg_stat_statements pgss order by calls;
-- select relid, schemaname, pgs.relname, pg_relation_size(schemaname||'.'||pgs.relname) size, n_tup_ins inserted, n_tup_upd updated, n_tup_del deleted, n_tup_hot_upd hot_upd, last_autovacuum, greatest(last_autoanalyze,last_analyze)||' (dead:'||n_dead_tup||')' as analyzed,  greatest(autovacuum_count, vacuum_count) as vacuum_cnt, age(pgc.relfrozenxid) from pg_stat_all_tables pgs, pg_class pgc where pgs.relid = pgc.oid and pgs.schemaname not in ('information_schema', 'pg_catalog', 'pg_toast', 'dwh_ods_grant_manage', 'activity_history') order by relname;
\set tt 'select schemaname, pgs.relname, pg_relation_size(schemaname||$$."$$||pgs.relname||$$"$$) size, pgc.reltuples::bigint rows, pgc.relpages::bigint pages, n_tup_ins inserted, n_tup_upd updated, n_tup_del deleted, n_tup_hot_upd hot_upd, to_char(last_autovacuum, $$YYYY-MM-DD HH24:MI:SS$$) last_autovacuum, round(current_setting($$autovacuum_vacuum_threshold$$)::numeric + current_setting($$autovacuum_vacuum_scale_factor$$)::numeric*n_live_tup - n_dead_tup) as neartovcm, to_char(greatest(last_autoanalyze,last_analyze), $$YYYY-MM-DD HH24:MI:SS$$) as analyzed, n_live_tup live,  n_dead_tup dead, pg_stat_get_dead_tuples(pgc.oid) > round(current_setting($$autovacuum_vacuum_threshold$$)::INTEGER + current_setting($$autovacuum_vacuum_scale_factor$$)::NUMERIC * pgc.reltuples) AS av_needed, (current_setting($$autovacuum_freeze_max_age$$)::NUMERIC < age(pgc.relfrozenxid)::NUMERIC)||$$ $$||age(pgc.relfrozenxid) frz_needed, pgc.reloptions from pg_stat_user_tables pgs, pg_class pgc where pgs.relid = pgc.oid and pgs.schemaname not in ($$dwh_ods_grant_manage$$, $$activity_history$$) order by relname;'
\set ii 'select i.indrelid, sti.indexrelid, sti.schemaname, sti.relname, c.relname indexrelname, sti.idx_scan, sti.idx_tup_read, sti.idx_tup_fetch, i.indisvalid from pg_stat_user_indexes sti right join pg_index i on i.indexrelid = sti.indexrelid join pg_class c on c.oid = i.indexrelid order by relname nulls first, indexrelname;'
-- select magic, root, level, fastroot, fastlevel, oldest_xact, last_cleanup_num_tuples::numeric from bt_metap('customer_time_zone_customer_id_key');
\set qw12 'select queryid, (select usename from pg_user pu where pu.usesysid = pgss.userid), calls, calls/nullif(rows,0) as "RowsPerCall", mean_time "ExecTime", shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS "HitPercent", query from pg_stat_statements pgss order by calls;'
\set qw 'select queryid, pg_get_userbyid(pss.userid) usename, calls, calls/nullif(rows,0) as "RowsPerCall", min_exec_time "ExecTime", shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS "HitPercent", query from pg_stat_statements pss order by calls;'
\set ss 'select client_addr, client_hostname, count(1) from pg_stat_activity where client_addr is not null group by grouping sets ((client_addr,client_hostname), ()) order by 3;'
\set cpu12 'select * from (SELECT (select usename from pg_user pu where pu.usesysid = pss.userid), round(pss.total_time::numeric, 2) as total_time, pss.calls, round(pss.mean_time::numeric, 2) as mean, round((100 * pss.total_time / sum(pss.total_time::numeric) OVER ())::numeric, 2) as cpu_portion_pctg,pss.query FROM pg_stat_statements pss ORDER BY pss.total_time desc LIMIT 10) a order by a.total_time;'
\set cpu 'select * from (SELECT  pg_get_userbyid(pss.userid) usename, round((pss.rows::numeric/pss.calls::numeric), 2) rows , pss.calls,  round((pss.mean_exec_time+pss.mean_plan_time)::numeric, 2) as exec_time,  round((100 * (pss.total_exec_time + pss.total_plan_time) / sum((pss.total_exec_time + pss.total_plan_time)::numeric) OVER ())::numeric, 2) as "cpu_%", pss.queryid, pss.query FROM pg_stat_statements pss ORDER BY (pss.total_exec_time + pss.total_plan_time) DESC LIMIT 10 ) a order by "cpu_%";'
\set stat 'select schemaname, tablename, attname, inherited, null_frac, avg_width, n_distinct, correlation, left(histogram_bounds::text,60) || $$...$$ AS hist_bounds from pg_stats where schemaname not in ($$information_schema$$, $$pg_catalog$$) order by tablename;'
\set rx 'SELECT now()::TIME(0), a.query, p.phase, round(p.blocks_done / (case when p.blocks_total = 0 then 1 else p.blocks_total end)::numeric * 100, 1) AS done, p.blocks_total, p.blocks_done, p.tuples_total, p.tuples_done, ai.schemaname, ai.relname, ai.indexrelname FROM pg_stat_progress_create_index p JOIN pg_stat_activity a ON p.pid = a.pid LEFT JOIN pg_stat_all_indexes ai on ai.relid = p.relid AND ai.indexrelid = p.index_relid;'
\set bi 'select * from bi;'
\set cron 'select * from cron.job;'
\set fk 'SELECT tc.table_schema, tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_schema AS foreign_table_schema,ccu.table_name AS foreign_table_name,ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name AND tc.table_schema = kcu.table_schema JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE tc.constraint_type = $$FOREIGN KEY$$;'
\set cpst 'select * from pg_stat_progress_copy;'
